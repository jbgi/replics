<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libfprint: Stored prints</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Stored prints</h1>Stored prints are represented by a structure named <code>fp_print_data</code>.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a> { <br>
&nbsp;&nbsp;<b>LEFT_THUMB</b> =  1, 
<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d58e451ff5c90ff6cf44d266af59d3bcc7">LEFT_INDEX</a>, 
<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d50d98404411ee5451af67ff3fa419bc56">LEFT_MIDDLE</a>, 
<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d5eca4b184f4328b2dfdb5530efe124091">LEFT_RING</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d5929a14ed753c249a9ceabc76defc6ef0">LEFT_LITTLE</a>, 
<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d57f13e23fab6f5ade33ec9c8491a3bf25">RIGHT_THUMB</a>, 
<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d5da22d9991d3f5cb22d59ae92496af023">RIGHT_INDEX</a>, 
<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d563368eff7313a8e9441fa71d49fa9f71">RIGHT_MIDDLE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d5a062124fa518709ad3b4a26085cc6d23">RIGHT_RING</a>, 
<a class="el" href="group__print__data.html#gg5c6d4e10ca53fd0b61eaa4716f3985d53aac8fd26588f140348ac03416e5e3c9">RIGHT_LITTLE</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Numeric codes used to refer to fingers (and thumbs) of a human.  <a href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#g3e3d0244d35990e2019a70dd2dc24de0">fp_print_data_get_data</a> (struct fp_print_data *data, unsigned char **ret)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a stored print into a unified representation inside a data buffer.  <a href="#g3e3d0244d35990e2019a70dd2dc24de0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct fp_print_data *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#gb5032f4f0d5e3e386ed7452c08c27562">fp_print_data_from_data</a> (unsigned char *buf, size_t buflen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a stored print from a data buffer.  <a href="#gb5032f4f0d5e3e386ed7452c08c27562"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#g98b1ba5a31560e8e9831cbe914268cc0">fp_print_data_save</a> (struct fp_print_data *data, enum <a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a> finger)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves a stored print to disk, assigned to a specific finger.  <a href="#g98b1ba5a31560e8e9831cbe914268cc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#g55244830b6ad7e4a04d184d95bc7e865">fp_print_data_load</a> (struct fp_dev *dev, enum <a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a> finger, struct fp_print_data **data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a previously stored print from disk.  <a href="#g55244830b6ad7e4a04d184d95bc7e865"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#ge7fd437d8bcd9026f7b3fa72068f6353">fp_print_data_delete</a> (struct fp_dev *dev, enum <a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a> finger)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a stored print from disk previously saved with <a class="el" href="group__print__data.html#g98b1ba5a31560e8e9831cbe914268cc0" title="Saves a stored print to disk, assigned to a specific finger.">fp_print_data_save()</a>.  <a href="#ge7fd437d8bcd9026f7b3fa72068f6353"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#gb7d990f770aa6139ac84a688ae202382">fp_print_data_from_dscv_print</a> (struct fp_dscv_print *print, struct fp_print_data **data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to load a stored print based on a <a class="el" href="group__dscv__print.html">discovered print</a> record.  <a href="#gb7d990f770aa6139ac84a688ae202382"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#g196516e2967ba5f6244299a179fdb1b7">fp_print_data_free</a> (struct fp_print_data *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a stored print.  <a href="#g196516e2967ba5f6244299a179fdb1b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#g6160a7a0a909f7d263a22a0777550383">fp_print_data_get_driver_id</a> (struct fp_print_data *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the <a class="el" href="group__drv.html#driver_id">driver ID</a> for a stored print.  <a href="#g6160a7a0a909f7d263a22a0777550383"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__print__data.html#g7aae2b0091ddb586a5e5bec9031a4969">fp_print_data_get_devtype</a> (struct fp_print_data *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the <a class="el" href="group__dev.html#devtype">devtype</a> for a stored print.  <a href="#g7aae2b0091ddb586a5e5bec9031a4969"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Stored prints are represented by a structure named <code>fp_print_data</code>. 
<p>
Stored prints are originally obtained from an enrollment function such as <a class="el" href="group__dev.html#g6fbb9f101f718f06c19f4ccabd112e17" title="Performs an enroll stage.">fp_enroll_finger()</a>.<p>
This page documents the various operations you can do with a stored print. Note that by default, "stored prints" are not actually stored anywhere except in RAM. For the simple scenarios, libfprint provides a simple API for you to save and load the stored prints referring to a single user in their home directory. For more advanced users, libfprint provides APIs for you to convert print data to a byte string, and to reconstruct stored prints from such data at a later point. You are welcome to store these byte strings in any fashion that suits you. <hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g5c6d4e10ca53fd0b61eaa4716f3985d5"></a><!-- doxytag: member="fprint.h::fp_finger" ref="g5c6d4e10ca53fd0b61eaa4716f3985d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Numeric codes used to refer to fingers (and thumbs) of a human. 
<p>
These are purposely not available as strings, to avoid getting the library tangled up in localization efforts. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d58e451ff5c90ff6cf44d266af59d3bcc7"></a><!-- doxytag: member="LEFT_INDEX" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d58e451ff5c90ff6cf44d266af59d3bcc7" args="" -->LEFT_INDEX</em>&nbsp;</td><td>
thumb (left hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d50d98404411ee5451af67ff3fa419bc56"></a><!-- doxytag: member="LEFT_MIDDLE" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d50d98404411ee5451af67ff3fa419bc56" args="" -->LEFT_MIDDLE</em>&nbsp;</td><td>
index finger (left hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d5eca4b184f4328b2dfdb5530efe124091"></a><!-- doxytag: member="LEFT_RING" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d5eca4b184f4328b2dfdb5530efe124091" args="" -->LEFT_RING</em>&nbsp;</td><td>
middle finger (left hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d5929a14ed753c249a9ceabc76defc6ef0"></a><!-- doxytag: member="LEFT_LITTLE" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d5929a14ed753c249a9ceabc76defc6ef0" args="" -->LEFT_LITTLE</em>&nbsp;</td><td>
ring finger (left hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d57f13e23fab6f5ade33ec9c8491a3bf25"></a><!-- doxytag: member="RIGHT_THUMB" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d57f13e23fab6f5ade33ec9c8491a3bf25" args="" -->RIGHT_THUMB</em>&nbsp;</td><td>
little finger (left hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d5da22d9991d3f5cb22d59ae92496af023"></a><!-- doxytag: member="RIGHT_INDEX" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d5da22d9991d3f5cb22d59ae92496af023" args="" -->RIGHT_INDEX</em>&nbsp;</td><td>
thumb (right hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d563368eff7313a8e9441fa71d49fa9f71"></a><!-- doxytag: member="RIGHT_MIDDLE" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d563368eff7313a8e9441fa71d49fa9f71" args="" -->RIGHT_MIDDLE</em>&nbsp;</td><td>
index finger (right hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d5a062124fa518709ad3b4a26085cc6d23"></a><!-- doxytag: member="RIGHT_RING" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d5a062124fa518709ad3b4a26085cc6d23" args="" -->RIGHT_RING</em>&nbsp;</td><td>
middle finger (right hand) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg5c6d4e10ca53fd0b61eaa4716f3985d53aac8fd26588f140348ac03416e5e3c9"></a><!-- doxytag: member="RIGHT_LITTLE" ref="gg5c6d4e10ca53fd0b61eaa4716f3985d53aac8fd26588f140348ac03416e5e3c9" args="" -->RIGHT_LITTLE</em>&nbsp;</td><td>
ring finger (right hand) </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g3e3d0244d35990e2019a70dd2dc24de0"></a><!-- doxytag: member="data.c::fp_print_data_get_data" ref="g3e3d0244d35990e2019a70dd2dc24de0" args="(struct fp_print_data *data, unsigned char **ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fp_print_data_get_data           </td>
          <td>(</td>
          <td class="paramtype">struct fp_print_data *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a stored print into a unified representation inside a data buffer. 
<p>
You can then store this data buffer in any way that suits you, and load it back at some later time using <a class="el" href="group__print__data.html#gb5032f4f0d5e3e386ed7452c08c27562" title="Load a stored print from a data buffer.">fp_print_data_from_data()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the stored print </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ret</em>&nbsp;</td><td>output location for the data buffer. Must be freed with free() after use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the freshly allocated buffer, or 0 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb5032f4f0d5e3e386ed7452c08c27562"></a><!-- doxytag: member="data.c::fp_print_data_from_data" ref="gb5032f4f0d5e3e386ed7452c08c27562" args="(unsigned char *buf, size_t buflen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fp_print_data* fp_print_data_from_data           </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>buflen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a stored print from a data buffer. 
<p>
The contents of said buffer must be the untouched contents of a buffer previously supplied to you by the <a class="el" href="group__print__data.html#g3e3d0244d35990e2019a70dd2dc24de0" title="Convert a stored print into a unified representation inside a data buffer.">fp_print_data_get_data()</a> function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buflen</em>&nbsp;</td><td>the length of the buffer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the stored print represented by the data, or NULL on error. Must be freed with <a class="el" href="group__print__data.html#g196516e2967ba5f6244299a179fdb1b7" title="Frees a stored print.">fp_print_data_free()</a> after use. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g98b1ba5a31560e8e9831cbe914268cc0"></a><!-- doxytag: member="data.c::fp_print_data_save" ref="g98b1ba5a31560e8e9831cbe914268cc0" args="(struct fp_print_data *data, enum fp_finger finger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_print_data_save           </td>
          <td>(</td>
          <td class="paramtype">struct fp_print_data *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a>&nbsp;</td>
          <td class="paramname"> <em>finger</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves a stored print to disk, assigned to a specific finger. 
<p>
Even though you are limited to storing only the 10 human fingers, this is a per-device-type limit. For example, you can store the users right index finger from a DigitalPersona scanner, and you can also save the right index finger from a UPEK scanner. When you later come to load the print, the right one will be automatically selected.<p>
This function will unconditionally overwrite a fingerprint previously saved for the same finger and device type. The print is saved in a hidden directory beneath the current user's home directory. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the stored print to save to disk </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finger</em>&nbsp;</td><td>the finger that this print corresponds to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g55244830b6ad7e4a04d184d95bc7e865"></a><!-- doxytag: member="data.c::fp_print_data_load" ref="g55244830b6ad7e4a04d184d95bc7e865" args="(struct fp_dev *dev, enum fp_finger finger, struct fp_print_data **data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_print_data_load           </td>
          <td>(</td>
          <td class="paramtype">struct fp_dev *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a>&nbsp;</td>
          <td class="paramname"> <em>finger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fp_print_data **&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a previously stored print from disk. 
<p>
The print must have been saved earlier using the <a class="el" href="group__print__data.html#g98b1ba5a31560e8e9831cbe914268cc0" title="Saves a stored print to disk, assigned to a specific finger.">fp_print_data_save()</a> function.<p>
A return code of -ENOENT indicates that the fingerprint requested could not be found. Other error codes (both positive and negative) are possible for obscure error conditions (e.g. corruption).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>the device you are loading the print for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finger</em>&nbsp;</td><td>the finger of the file you are loading </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>output location to put the corresponding stored print. Must be freed with <a class="el" href="group__print__data.html#g196516e2967ba5f6244299a179fdb1b7" title="Frees a stored print.">fp_print_data_free()</a> after use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge7fd437d8bcd9026f7b3fa72068f6353"></a><!-- doxytag: member="data.c::fp_print_data_delete" ref="ge7fd437d8bcd9026f7b3fa72068f6353" args="(struct fp_dev *dev, enum fp_finger finger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_print_data_delete           </td>
          <td>(</td>
          <td class="paramtype">struct fp_dev *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__print__data.html#g5c6d4e10ca53fd0b61eaa4716f3985d5">fp_finger</a>&nbsp;</td>
          <td class="paramname"> <em>finger</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a stored print from disk previously saved with <a class="el" href="group__print__data.html#g98b1ba5a31560e8e9831cbe914268cc0" title="Saves a stored print to disk, assigned to a specific finger.">fp_print_data_save()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>the device that the print belongs to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finger</em>&nbsp;</td><td>the finger of the file you are deleting </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, negative on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb7d990f770aa6139ac84a688ae202382"></a><!-- doxytag: member="data.c::fp_print_data_from_dscv_print" ref="gb7d990f770aa6139ac84a688ae202382" args="(struct fp_dscv_print *print, struct fp_print_data **data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_print_data_from_dscv_print           </td>
          <td>(</td>
          <td class="paramtype">struct fp_dscv_print *&nbsp;</td>
          <td class="paramname"> <em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fp_print_data **&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to load a stored print based on a <a class="el" href="group__dscv__print.html">discovered print</a> record. 
<p>
A return code of -ENOENT indicates that the file referred to by the discovered print could not be found. Other error codes (both positive and negative) are possible for obscure error conditions (e.g. corruption).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>print</em>&nbsp;</td><td>the discovered print </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>output location to point to the corresponding stored print. Must be freed with <a class="el" href="group__print__data.html#g196516e2967ba5f6244299a179fdb1b7" title="Frees a stored print.">fp_print_data_free()</a> after use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g196516e2967ba5f6244299a179fdb1b7"></a><!-- doxytag: member="data.c::fp_print_data_free" ref="g196516e2967ba5f6244299a179fdb1b7" args="(struct fp_print_data *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fp_print_data_free           </td>
          <td>(</td>
          <td class="paramtype">struct fp_print_data *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees a stored print. 
<p>
Must be called when you are finished using the print. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the stored print to destroy. If NULL, function simply returns. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6160a7a0a909f7d263a22a0777550383"></a><!-- doxytag: member="data.c::fp_print_data_get_driver_id" ref="g6160a7a0a909f7d263a22a0777550383" args="(struct fp_print_data *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fp_print_data_get_driver_id           </td>
          <td>(</td>
          <td class="paramtype">struct fp_print_data *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the <a class="el" href="group__drv.html#driver_id">driver ID</a> for a stored print. 
<p>
The driver ID indicates which driver the print originally came from. The print is only usable with a device controlled by that driver. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the stored print </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the driver ID of the driver compatible with the print </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7aae2b0091ddb586a5e5bec9031a4969"></a><!-- doxytag: member="data.c::fp_print_data_get_devtype" ref="g7aae2b0091ddb586a5e5bec9031a4969" args="(struct fp_print_data *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fp_print_data_get_devtype           </td>
          <td>(</td>
          <td class="paramtype">struct fp_print_data *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the <a class="el" href="group__dev.html#devtype">devtype</a> for a stored print. 
<p>
The devtype represents which type of device under the parent driver is compatible with the print. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the stored print </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the devtype of the device range compatible with the print </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jan 6 17:47:48 2008 for libfprint by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
