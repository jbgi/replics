<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libfprint: Image operations</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Image operations</h1>libfprint offers several ways of retrieving images from imaging devices, one example being the <a class="el" href="group__dev.html#ga7a7f70b12f0276df4749d23caf2cecd" title="Captures an image from a device.">fp_dev_img_capture()</a> function.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>fp_minutia</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#g18dcdd8c27abc8980e4fb9775e84da35">fp_img_free</a> (struct fp_img *img)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees an image.  <a href="#g18dcdd8c27abc8980e4fb9775e84da35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#g243dd89512cf44189fd5a9a63da53153">fp_img_get_height</a> (struct fp_img *img)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the pixel height of an image.  <a href="#g243dd89512cf44189fd5a9a63da53153"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#g8481ce980f6cd9ed3c22e407f342a039">fp_img_get_width</a> (struct fp_img *img)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the pixel width of an image.  <a href="#g8481ce980f6cd9ed3c22e407f342a039"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#g29904671177c5860af01a98dda91c8d6">fp_img_get_data</a> (struct fp_img *img)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the greyscale data for an image.  <a href="#g29904671177c5860af01a98dda91c8d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#g42878cabc584c56a5f225d5340319dfa">fp_img_save_to_file</a> (struct fp_img *img, char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A quick convenience function to save an image to a file in <a href="http://netpbm.sourceforge.net/doc/pgm.html">PGM format</a>.  <a href="#g42878cabc584c56a5f225d5340319dfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#g4b3b9e9043c3534b31622723f9e32a85">fp_img_standardize</a> (struct fp_img *img)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__img.html#img_std">Standardizes</a> an image by normalizing its orientation, colors, etc.  <a href="#g4b3b9e9043c3534b31622723f9e32a85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct fp_img *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#g4c4515b326b9893b9c3dc87c6c4e30d8">fp_img_binarize</a> (struct fp_img *img)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a binarized form of a standardized scanned image.  <a href="#g4c4515b326b9893b9c3dc87c6c4e30d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct fp_minutia **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__img.html#gb45fcd7736793a56a8be9d78a6267796">fp_img_get_minutiae</a> (struct fp_img *img, int *nr_minutiae)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of minutiae detected in an image.  <a href="#gb45fcd7736793a56a8be9d78a6267796"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
libfprint offers several ways of retrieving images from imaging devices, one example being the <a class="el" href="group__dev.html#ga7a7f70b12f0276df4749d23caf2cecd" title="Captures an image from a device.">fp_dev_img_capture()</a> function. 
<p>
The functions documented below allow you to work with such images.<h2><a class="anchor" name="img_fmt">
Image format</a></h2>
All images are represented as 8-bit greyscale data.<h2><a class="anchor" name="img_std">
Image standardization</a></h2>
In some contexts, images you are provided through libfprint are raw images from the hardware. The orientation of these varies from device-to-device, as does the color scheme (black-on-white or white-on-black?). libfprint provides the fp_img_standardize function to convert images into standard form, which is defined to be: finger flesh as black on white surroundings, natural upright orientation. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g18dcdd8c27abc8980e4fb9775e84da35"></a><!-- doxytag: member="img.c::fp_img_free" ref="g18dcdd8c27abc8980e4fb9775e84da35" args="(struct fp_img *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fp_img_free           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees an image. 
<p>
Must be called when you are finished working with an image. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>the image to destroy. If NULL, function simply returns. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g243dd89512cf44189fd5a9a63da53153"></a><!-- doxytag: member="img.c::fp_img_get_height" ref="g243dd89512cf44189fd5a9a63da53153" args="(struct fp_img *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_img_get_height           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the pixel height of an image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>an image </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the height of the image </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8481ce980f6cd9ed3c22e407f342a039"></a><!-- doxytag: member="img.c::fp_img_get_width" ref="g8481ce980f6cd9ed3c22e407f342a039" args="(struct fp_img *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_img_get_width           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the pixel width of an image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>an image </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the width of the image </dd></dl>

</div>
</div><p>
<a class="anchor" name="g29904671177c5860af01a98dda91c8d6"></a><!-- doxytag: member="img.c::fp_img_get_data" ref="g29904671177c5860af01a98dda91c8d6" args="(struct fp_img *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* fp_img_get_data           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the greyscale data for an image. 
<p>
This data must not be modified or freed, and must not be used after <a class="el" href="group__img.html#g18dcdd8c27abc8980e4fb9775e84da35" title="Frees an image.">fp_img_free()</a> has been called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>an image </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to libfprint's internal data for the image </dd></dl>

</div>
</div><p>
<a class="anchor" name="g42878cabc584c56a5f225d5340319dfa"></a><!-- doxytag: member="img.c::fp_img_save_to_file" ref="g42878cabc584c56a5f225d5340319dfa" args="(struct fp_img *img, char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_img_save_to_file           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A quick convenience function to save an image to a file in <a href="http://netpbm.sourceforge.net/doc/pgm.html">PGM format</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>the image to save </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>the path to save the image. Existing files will be overwritten. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, non-zero on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4b3b9e9043c3534b31622723f9e32a85"></a><!-- doxytag: member="img.c::fp_img_standardize" ref="g4b3b9e9043c3534b31622723f9e32a85" args="(struct fp_img *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fp_img_standardize           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__img.html#img_std">Standardizes</a> an image by normalizing its orientation, colors, etc. 
<p>
It is safe to call this multiple times on an image, libfprint keeps track of the work it needs to do to make an image standard and will not perform these operations more than once for a given image. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>the image to standardize </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4c4515b326b9893b9c3dc87c6c4e30d8"></a><!-- doxytag: member="img.c::fp_img_binarize" ref="g4c4515b326b9893b9c3dc87c6c4e30d8" args="(struct fp_img *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fp_img* fp_img_binarize           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a binarized form of a standardized scanned image. 
<p>
This is where the fingerprint image has been "enhanced" and is a set of pure black ridges on a pure white background. Internally, image processing happens on top of the binarized image.<p>
The image must have been <a class="el" href="group__img.html#img_std">standardized</a> otherwise this function will fail.<p>
It is safe to binarize an image and free the original while continuing to use the binarized version.<p>
You cannot binarize an image twice.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>a standardized image </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new image representing the binarized form of the original, or NULL on error. Must be freed with <a class="el" href="group__img.html#g18dcdd8c27abc8980e4fb9775e84da35" title="Frees an image.">fp_img_free()</a> after use. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb45fcd7736793a56a8be9d78a6267796"></a><!-- doxytag: member="img.c::fp_img_get_minutiae" ref="gb45fcd7736793a56a8be9d78a6267796" args="(struct fp_img *img, int *nr_minutiae)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fp_minutia** fp_img_get_minutiae           </td>
          <td>(</td>
          <td class="paramtype">struct fp_img *&nbsp;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nr_minutiae</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a list of minutiae detected in an image. 
<p>
A minutia point is a feature detected on a fingerprint, typically where ridges end or split. libfprint's image processing code relies upon comparing sets of minutiae, so accurate placement of minutia points is critical for good imaging performance.<p>
The image must have been <a class="el" href="group__img.html#img_std">standardized</a> otherwise this function will fail.<p>
You cannot pass a binarized image to this function. Instead, pass the original image.<p>
Returns a list of pointers to minutiae, where the list is of length indicated in the nr_minutiae output parameter. The returned list is only valid while the parent image has not been freed, and the minutiae data must not be modified or freed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>img</em>&nbsp;</td><td>a standardized image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nr_minutiae</em>&nbsp;</td><td>an output location to store minutiae list length </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a list of minutiae points. Must not be modified or freed. </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jan 6 17:47:48 2008 for libfprint by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
